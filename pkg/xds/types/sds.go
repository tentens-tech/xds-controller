// Copyright 2025 The Envoy XDS Controller Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package types

import "errors"

type LetsEncryptAccount struct {
	Email            string `yaml:"Email"`
	PrivateKeyBase64 string `yaml:"PrivateKeyBase64,omitempty"`
}

type DomainConfig struct {
	SecretName string   `yaml:"SecretName" json:"secret_name,omitempty"`
	Domains    []string `yaml:"Domains" json:"domains"`

	Challenge *ChallengeConfig `yaml:"Challenge,omitempty" json:"challenge,omitempty"`

	Config StorageConfig `yaml:"Config,omitempty" json:"config,omitempty"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DomainConfig) DeepCopyInto(out *DomainConfig) {
	*out = *in
	if in.Domains != nil {
		out.Domains = make([]string, len(in.Domains))
		copy(out.Domains, in.Domains)
	}
	if in.Challenge != nil {
		out.Challenge = &ChallengeConfig{}
		*out.Challenge = *in.Challenge
		if in.Challenge.CustomDNS01ProviderEnvReplace != nil {
			out.Challenge.CustomDNS01ProviderEnvReplace = make([]string, len(in.Challenge.CustomDNS01ProviderEnvReplace))
			copy(out.Challenge.CustomDNS01ProviderEnvReplace, in.Challenge.CustomDNS01ProviderEnvReplace)
		}
	}
	if in.Config.LocalStorageConfig != nil {
		out.Config.LocalStorageConfig = &LocalStorageConfig{}
		*out.Config.LocalStorageConfig = *in.Config.LocalStorageConfig
	}
	if in.Config.VaultStorageConfig != nil {
		out.Config.VaultStorageConfig = &VaultStorageConfig{}
		*out.Config.VaultStorageConfig = *in.Config.VaultStorageConfig
	}
	if in.Config.KubernetesStorageConfig != nil {
		out.Config.KubernetesStorageConfig = &KubernetesStorageConfig{}
		*out.Config.KubernetesStorageConfig = *in.Config.KubernetesStorageConfig
	}
}

type ChallengeConfig struct {
	ChallengeType ChallengeType          `yaml:"ChallengeType,omitempty" json:"challenge_type,omitempty"`
	DNS01Provider string                 `yaml:"DNS01Provider,omitempty" json:"dns01_provider,omitempty"`
	ACMEEnv       LetsEncryptACMEUrlType `yaml:"ACMEEnv,omitempty" json:"acme_env,omitempty"`

	// env vars pairs for DNS01Provider, for example: MY_OTHER_ACCOUNT_API_KEY, CLOUDFLARE_API_KEY
	// when DNS01 provider will be used, it will temporary assing the first value of the first ENV variable to the second env var value, TEMPORARY
	// the first env variable in pair should be assigned globally
	CustomDNS01ProviderEnvReplace []string `yaml:"CustomDNS01EnvReplacer,omitempty" json:"custom_dns01_env_replace,omitempty"`
}

type StorageConfig struct {
	Type                     CertStore `yaml:"Type" json:"type,omitempty"`
	*LocalStorageConfig      `yaml:"LocalStorageConfig" json:"local_config,omitempty"`
	*VaultStorageConfig      `yaml:"VaultStorageConfig" json:"vault_config,omitempty"`
	*KubernetesStorageConfig `yaml:"KubernetesStorageConfig" json:"kubernetes_config,omitempty"`
}

type LocalStorageConfig struct {
	Path            string `yaml:"Path,omitempty" json:"path,omitempty"`
	Base64CACert    string `yaml:"Base64CACert,omitempty" json:"base64_ca_cert,omitempty"`
	Base64CAKey     string `yaml:"Base64CAKey,omitempty" json:"base64_ca_key,omitempty"`
	ExpireAfterDays int    `yaml:"ExpireAfterDays,omitempty" json:"expire_after_days,omitempty"`
}

type VaultStorageConfig struct {
	Path          string `yaml:"Path,omitempty" json:"path,omitempty"`
	URL           string `yaml:"URL,omitempty" json:"url,omitempty"`
	Token         string `yaml:"Token,omitempty" json:"token,omitempty"`
	SkipTLSVerify bool   `yaml:"SkipTLSVerify,omitempty" json:"skip_tls_verify,omitempty"`
}

type KubernetesStorageConfig struct {
	// Namespace is the Kubernetes namespace where the secret will be stored
	// If empty, uses the same namespace as the TLSSecret resource
	Namespace string `yaml:"Namespace,omitempty" json:"namespace,omitempty"`
	// SecretName is the name of the Kubernetes Secret to store the certificate
	// If empty, uses the TLSSecret resource name
	SecretName string `yaml:"SecretName,omitempty" json:"secret_name,omitempty"`
}

type ChallengeType string

const (
	HTTP01 ChallengeType = "HTTP01"
	DNS01  ChallengeType = "DNS01"
	MANUAL ChallengeType = "MANUAL"
)

type DNS01Type string

type LetsEncryptACMEUrlType string

const (
	Staging    LetsEncryptACMEUrlType = "Staging"
	Production LetsEncryptACMEUrlType = "Production"
)

func (t LetsEncryptACMEUrlType) String() string {
	switch t {
	case Staging:
		return "https://acme-staging-v02.api.letsencrypt.org/directory"
	case Production:
		return "https://acme-v02.api.letsencrypt.org/directory"
	default:
		return ""
	}
}

type CertStore string

const (
	Local      CertStore = "Local"
	Vault      CertStore = "Vault"
	Kubernetes CertStore = "Kubernetes"
)

type Cert struct {
	Pub  []byte
	Priv []byte
}

var ErrCertNotFound = errors.New("cert not found")
var ErrNoResourcesFound = errors.New("no resources found")

## SDS (Secret Discovery Service)

The Secret Discovery Service (SDS) in the control-plane xDS service for Envoy provides a way to dynamically discover and manage TLS certificates and other secrets for Envoy proxies. SDS allows you to configure different types of secret providers and specify the domains or wildcard domains for which the secrets should be managed.

[Back to Main](../../README.md)

### Storage Types

SDS supports three storage backends for certificates:

| Type | Description | Use Case |
| ---- | ----------- | -------- |
| `Kubernetes` | Store certificates as Kubernetes Secrets | Default for Let's Encrypt (no Vault) |
| `Vault` | Store certificates in HashiCorp Vault | Production with centralized secret management |
| `Local` | Store certificates on local filesystem | Self-signed certs for development |

### Automatic Storage Selection

If no storage type is explicitly configured, SDS automatically selects the appropriate storage:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Storage Selection Logic                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  With Let's Encrypt Challenge:                                   â”‚
â”‚    1. Vault (if configured in resource or global)               â”‚
â”‚    2. Kubernetes Secrets (default fallback)                      â”‚
â”‚                                                                  â”‚
â”‚  Without Challenge (Self-signed):                                â”‚
â”‚    1. Kubernetes (if kubernetes_config specified)               â”‚
â”‚    2. Local (if local_config.path specified)                    â”‚
â”‚    3. Kubernetes (if K8s client available)                       â”‚
â”‚    4. Local (final fallback)                                     â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Example Configurations

[SDS Example config](../../config/samples/sds_v1alpha1_tlssecret.yaml)

#### Kubernetes Storage (Default for Let's Encrypt)

Certificates are stored as Kubernetes Secrets. This is the default when no Vault is configured:

```yaml
apiVersion: envoyxds.io/v1alpha1
kind: TLSSecret
metadata:
  name: my-domain-cert
  namespace: default
spec:
  domains:
    - "example.com"
    - "*.example.com"
  challenge:
    challenge_type: DNS01
    dns01_provider: cloudflare
    acme_env: Production
```

The certificate will be stored in a Kubernetes Secret named `my-domain-cert` in the same namespace.

You can customize the storage location:

```yaml
apiVersion: envoyxds.io/v1alpha1
kind: TLSSecret
metadata:
  name: my-domain-cert
spec:
  domains:
    - "example.com"
  challenge:
    challenge_type: DNS01
    dns01_provider: cloudflare
    acme_env: Production
  config:
    type: Kubernetes
    kubernetes_config:
      namespace: certs-namespace
      secret_name: custom-secret-name
```

#### Custom Vault Configuration

The following example configures a custom Vault configuration for managing secrets:

```yaml
apiVersion: envoyxds.io/v1alpha1
kind: TLSSecret
metadata:
  name: secret
spec:
  domains:
    - "domain.com"
  challenge:
    challenge_type: DNS01
    dns01_provider: cloudflare
    acme_env: Staging
  config:
    type: Vault
    vault_config:
      path: apps/envoy
      url: http://127.0.0.1:8200
      token: root
      skip_tls_verify: true
```

#### Global Vault Configuration

The following example configures a secret that uses the global Vault configuration:

```yaml
apiVersion: envoyxds.io/v1alpha1
kind: TLSSecret
metadata:
  name: secret
spec:
  domains:
    - "domain.com"
  challenge:
    challenge_type: DNS01
    dns01_provider: cloudflare
    acme_env: Staging
```

This configuration requires you to set the following environment variables:

- `XDS_LETS_ENCRYPT_EMAIL`: (required) Email to get notifications.

- `XDS_LETS_ENCRYPT_PRIVATEKEYB64`: RSA private key in base64 to register one account in let's encrypt, if it not assigned it will be autogenerated.

- `XDS_VAULT_URL`: This variable should be set to the URL of your Vault server.

- `XDS_VAULT_TOKEN`: This variable should be set to the token for accessing your Vault server.

- `XDS_VAULT_PATH`: kv2 secret path should be already created in vault, ex: "secret/envoy".

Please make sure to set these environment variables before applying the `TLSSecret` with the global Vault configuration.

#### Local Path Configuration

The following example configures a secret that saves the certificate to a local path (self-signed):

```yaml
apiVersion: envoyxds.io/v1alpha1
kind: TLSSecret
metadata:
  name: secret
spec:
  domains:
    - "*.domain.com"
  config:
    type: Local
    local_config:
      path: ./certs
```

#### Simple Local Self-Signed Certificate

For development/testing, you can create a minimal self-signed certificate:

```yaml
apiVersion: envoyxds.io/v1alpha1
kind: TLSSecret
metadata:
  name: local-cert
spec:
  domains:
    - "local.example.com"
  config:
    type: Local
```

#### Let's Encrypt Production Certificate

```yaml
apiVersion: envoyxds.io/v1alpha1
kind: TLSSecret
metadata:
  name: production-cert
spec:
  domains:
    - "example.com"
    - "*.example.com"
  challenge:
    challenge_type: DNS01
    dns01_provider: cloudflare
    acme_env: Production
```

### Environment Variables

#### Let's Encrypt (Required for ACME)

| Variable | Description | Required |
| -------- | ----------- | -------- |
| `XDS_LETS_ENCRYPT_EMAIL` | Email for Let's Encrypt notifications | Yes |
| `XDS_LETS_ENCRYPT_PRIVATEKEYB64` | Base64-encoded RSA private key for ACME account | No (auto-generated) |

#### Vault Storage (Optional)

| Variable | Description | Required |
| -------- | ----------- | -------- |
| `XDS_VAULT_URL` | Vault server URL (e.g., `http://vault:8200`) | If using Vault |
| `XDS_VAULT_TOKEN` | Vault authentication token | If using Vault |
| `XDS_VAULT_PATH` | KV2 secret path (e.g., `secret/envoy`) | If using Vault |

#### DNS Provider Environment Variables (Lego)

SDS uses [lego](https://github.com/go-acme/lego) for ACME certificate management. Each DNS provider requires specific environment variables.

**Common DNS Providers:**

| Provider | Environment Variables |
| -------- | --------------------- |
| Cloudflare | `CLOUDFLARE_DNS_API_TOKEN` or `CLOUDFLARE_API_KEY` + `CLOUDFLARE_EMAIL` |
| Google Cloud DNS | `GCE_PROJECT` + `GCE_SERVICE_ACCOUNT_FILE` or `GCE_SERVICE_ACCOUNT` |
| AWS Route53 | `AWS_ACCESS_KEY_ID` + `AWS_SECRET_ACCESS_KEY` + `AWS_REGION` |
| DigitalOcean | `DO_AUTH_TOKEN` |
| Azure DNS | `AZURE_CLIENT_ID` + `AZURE_CLIENT_SECRET` + `AZURE_TENANT_ID` + `AZURE_SUBSCRIPTION_ID` + `AZURE_RESOURCE_GROUP` |

ğŸ“š **Full list of supported DNS providers:** [lego DNS Providers Documentation](https://go-acme.github.io/lego/dns/)

### Explanation of Parameters

- `domains`: An array that contains the list of domains for which the secret should be managed, including wildcards.

- `challenge.challenge_type`: Specifies the challenge type for the secret. The following challenge types are available:
  - `MANUAL`: This type is used for monitoring existing certificates.
    - How to use and why do we have MANUAL type:
        create in your vault for example secret with name "myowncertificate" with two secret data keys
        Pub - with your public key in base64
        Priv - with your private key in base64
        create TLSSecret with name "myowncertificate" and set domains and challenge_type: MANUAL
        certificate will be added in to metrics
  - `HTTP01`: This type is used for a common challenge, but currently requires manual configuration of your ingress.
  - `DNS01`: This type requires you to prove that you control the DNS for your domain name by putting a specific value in a TXT record under that domain name.

- `challenge.dns01_provider`: The `dns01_provider` parameter specifies the DNS provider to be used for the "DNS01" challenge type. Various providers are available, including Cloudflare, GCloud, Clouddns, and others. Before adding your specified `TLSSecret`, make sure to configure the respective environment variables for your chosen provider.

  You can find a comprehensive list of other DNS providers [DNS Providers](https://go-acme.github.io/lego/dns/). This resource provides directories for various DNS providers, containing documentation and implementation details for each. By referring to this documentation, you can configure the `dns01_provider` parameter with the appropriate value for your desired DNS provider.

  For example, if you are using the Cloudflare provider, you will need to set the `CLOUDFLARE_DNS_API_TOKEN` environment variable before applying the `TLSSecret` with the Cloudflare provider.

- `challenge.acme_env`: Specifies the environment, either `Staging` or `Production`, for acquiring the certificate.

- `config.type`: Specifies the type of secret configuration. The following types are available:
  - `Kubernetes`: Stores certificates as Kubernetes Secrets (default for Let's Encrypt).
  - `Vault`: Specifies a custom Vault configuration.
  - `Local`: Specifies that the certificate will be saved to a local path (self-signed only).

- `config.kubernetes_config`: Specifies the Kubernetes storage parameters when `config.type` is set to `Kubernetes`.

  - `namespace`: Specifies the Kubernetes namespace where the secret will be stored. Defaults to the TLSSecret resource namespace.

  - `secret_name`: Specifies the name of the Kubernetes Secret. Defaults to the TLSSecret resource name.

- `config.vault_config`: Specifies the Vault configuration parameters when `config.type` is set to `Vault`. The parameters include the Vault path, URL, token, and whether to skip TLS verification.

  - `path`: Specifies the Vault path where the secrets are stored. In the example provided (`apps/envoy`), the secrets are expected to be stored under the `apps/envoy` path in Vault.

  - `url`: Specifies the URL of the Vault server. In the example provided (`http://127.0.0.1:8200`), the Vault server is assumed to be running locally on the IP address `127.0.0.1`, and the port `8200`.

  - `token`: Specifies the Vault token that should be used for authentication when accessing the secrets. In the example provided (`root`), the token is set to `root`. Note that in a production environment, it is recommended to use a more secure authentication method and not rely on the root token.

  - `skip_tls_verify`: Specifies whether to skip TLS verification when connecting to the Vault server. In the example provided (`true`), the TLS verification is skipped. It is important to note that skipping TLS verification can have security implications and should only be done in trusted environments.

- `config.local_config`: Specifies the local configuration parameters when `config.type` is set to `Local`.

  - `path`: Specifies the local path where the certificate should be saved. In the example provided (`./certs`), the certificate will be saved in a directory named `certs` in the current working directory with a relative path `./certs`.

  - `base64_ca_cert`: Your Root CA Cert in base64 string, must be assigned with key.

  - `base64_ca_key`: Your Root CA Key in base64 string, must be assigned with cert.

## Features

- Automatic TLS certificate management
- Kubernetes Secrets storage (default for Let's Encrypt)
- HashiCorp Vault integration
- Support for DNS-01 and HTTP-01 ACME challenges
- Multiple DNS provider support via [lego](https://github.com/go-acme/lego)
- Multi-account support for DNS providers
- Automatic certificate renewal
- Certificate expiry metrics

## Configuration

### DNS Provider Multi-Account Support

The SDS controller supports managing certificates across multiple accounts of the same DNS provider using the `custom_dns01_env_replace` feature.

#### How it works

The `custom_dns01_env_replace` configuration allows you to specify environment variable mappings for different accounts. When processing ACME challenges, the controller will replace the standard environment variable with your custom one.

Example configuration:

```yaml
spec:
  domains:
    - "example.com"
    - "*.example.com"
  challenge:
    challenge_type: DNS01
    dns01_provider: cloudflare
    acme_env: Production
    custom_dns01_env_replace: 
      - CLOUDFLARE_DNS_API_TOKEN_SECONDARY  # Custom environment variable for specific account
      - CLOUDFLARE_DNS_API_TOKEN            # Standard environment variable to be replaced
```

In this example:

1. The controller will use `CLOUDFLARE_DNS_API_TOKEN_SECONDARY` instead of `CLOUDFLARE_DNS_API_TOKEN`
2. This allows you to manage domains across different Cloudflare accounts
3. Each account can have its own API token set in the corresponding environment variable

#### Use Cases

1. **Multiple Client Accounts**
   - Manage domains for different clients using separate DNS provider accounts
   - Keep API tokens isolated for better security

2. **Environment Separation**
   - Use different accounts for development and production environments
   - Maintain separate access controls for each environment

3. **Account-Specific Permissions**
   - Use restricted API tokens for specific domains
   - Implement principle of least privilege for each account

#### Setup Steps

1. Set up environment variables for each account:

   ```bash
   export CLOUDFLARE_DNS_API_TOKEN_SECONDARY="token_for_account_1"
   export CLOUDFLARE_DNS_API_TOKEN_CLIENT2="token_for_account_2"
   ```

2. Configure domains to use specific accounts:

   ```yaml
   spec:
     domains:
       - "client1.com"
     challenge:
       dns01_provider: cloudflare
       custom_dns01_env_replace: 
         - CLOUDFLARE_DNS_API_TOKEN_SECONDARY
         - CLOUDFLARE_DNS_API_TOKEN
   ```

3. The controller will automatically use the correct API token for each domain's certificate management.
